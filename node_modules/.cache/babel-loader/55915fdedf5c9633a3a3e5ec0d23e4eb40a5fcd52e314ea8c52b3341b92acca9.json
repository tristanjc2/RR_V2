{"ast":null,"code":"import { validateFieldsNatively as r, toNestErrors as e } from \"@hookform/resolvers\";\nimport { appendErrors as o } from \"react-hook-form\";\nimport * as n from \"zod/v4/core\";\nfunction t(r, e) {\n  try {\n    var o = r();\n  } catch (r) {\n    return e(r);\n  }\n  return o && o.then ? o.then(void 0, e) : o;\n}\nfunction s(r, e) {\n  for (var n = {}; r.length;) {\n    var t = r[0],\n      s = t.code,\n      i = t.message,\n      a = t.path.join(\".\");\n    if (!n[a]) if (\"unionErrors\" in t) {\n      var u = t.unionErrors[0].errors[0];\n      n[a] = {\n        message: u.message,\n        type: u.code\n      };\n    } else n[a] = {\n      message: i,\n      type: s\n    };\n    if (\"unionErrors\" in t && t.unionErrors.forEach(function (e) {\n      return e.errors.forEach(function (e) {\n        return r.push(e);\n      });\n    }), e) {\n      var c = n[a].types,\n        f = c && c[t.code];\n      n[a] = o(a, e, n, s, f ? [].concat(f, t.message) : t.message);\n    }\n    r.shift();\n  }\n  return n;\n}\nfunction i(r, e) {\n  for (var n = {}; r.length;) {\n    var t = r[0],\n      s = t.code,\n      i = t.message,\n      a = t.path.join(\".\");\n    if (!n[a]) if (\"invalid_union\" === t.code) {\n      var u = t.errors[0][0];\n      n[a] = {\n        message: u.message,\n        type: u.code\n      };\n    } else n[a] = {\n      message: i,\n      type: s\n    };\n    if (\"invalid_union\" === t.code && t.errors.forEach(function (e) {\n      return e.forEach(function (e) {\n        return r.push(e);\n      });\n    }), e) {\n      var c = n[a].types,\n        f = c && c[t.code];\n      n[a] = o(a, e, n, s, f ? [].concat(f, t.message) : t.message);\n    }\n    r.shift();\n  }\n  return n;\n}\nfunction a(o, a, u) {\n  if (void 0 === u && (u = {}), function (r) {\n    return \"_def\" in r && \"object\" == typeof r._def && \"typeName\" in r._def;\n  }(o)) return function (n, i, c) {\n    try {\n      return Promise.resolve(t(function () {\n        return Promise.resolve(o[\"sync\" === u.mode ? \"parse\" : \"parseAsync\"](n, a)).then(function (e) {\n          return c.shouldUseNativeValidation && r({}, c), {\n            errors: {},\n            values: u.raw ? Object.assign({}, n) : e\n          };\n        });\n      }, function (r) {\n        if (function (r) {\n          return Array.isArray(null == r ? void 0 : r.issues);\n        }(r)) return {\n          values: {},\n          errors: e(s(r.errors, !c.shouldUseNativeValidation && \"all\" === c.criteriaMode), c)\n        };\n        throw r;\n      }));\n    } catch (r) {\n      return Promise.reject(r);\n    }\n  };\n  if (function (r) {\n    return \"_zod\" in r && \"object\" == typeof r._zod;\n  }(o)) return function (s, c, f) {\n    try {\n      return Promise.resolve(t(function () {\n        return Promise.resolve((\"sync\" === u.mode ? n.parse : n.parseAsync)(o, s, a)).then(function (e) {\n          return f.shouldUseNativeValidation && r({}, f), {\n            errors: {},\n            values: u.raw ? Object.assign({}, s) : e\n          };\n        });\n      }, function (r) {\n        if (function (r) {\n          return r instanceof n.$ZodError;\n        }(r)) return {\n          values: {},\n          errors: e(i(r.issues, !f.shouldUseNativeValidation && \"all\" === f.criteriaMode), f)\n        };\n        throw r;\n      }));\n    } catch (r) {\n      return Promise.reject(r);\n    }\n  };\n  throw new Error(\"Invalid input: not a Zod schema\");\n}\nexport { a as zodResolver };","map":{"version":3,"names":["s","r","e","n","length","t","code","i","message","a","path","join","u","unionErrors","errors","type","forEach","push","c","types","f","o","concat","shift","_def","Promise","resolve","mode","then","shouldUseNativeValidation","values","raw","Object","assign","Array","isArray","issues","criteriaMode","reject","_zod","parse","parseAsync","$ZodError","Error","zodResolver"],"sources":["C:\\RR_V3\\node_modules\\@hookform\\resolvers\\zod\\src\\zod.ts"],"sourcesContent":["import { toNestErrors, validateFieldsNatively } from '@hookform/resolvers';\nimport {\n  FieldError,\n  FieldErrors,\n  FieldValues,\n  Resolver,\n  ResolverError,\n  ResolverSuccess,\n  appendErrors,\n} from 'react-hook-form';\nimport * as z3 from 'zod/v3';\nimport * as z4 from 'zod/v4/core';\n\nconst isZod3Error = (error: any): error is z3.ZodError => {\n  return Array.isArray(error?.issues);\n};\nconst isZod3Schema = (schema: any): schema is z3.ZodSchema => {\n  return (\n    '_def' in schema &&\n    typeof schema._def === 'object' &&\n    'typeName' in schema._def\n  );\n};\nconst isZod4Error = (error: any): error is z4.$ZodError => {\n  // instanceof is safe in Zod 4 (uses Symbol.hasInstance)\n  return error instanceof z4.$ZodError;\n};\nconst isZod4Schema = (schema: any): schema is z4.$ZodType => {\n  return '_zod' in schema && typeof schema._zod === 'object';\n};\n\nfunction parseZod3Issues(\n  zodErrors: z3.ZodIssue[],\n  validateAllFieldCriteria: boolean,\n) {\n  const errors: Record<string, FieldError> = {};\n  for (; zodErrors.length; ) {\n    const error = zodErrors[0];\n    const { code, message, path } = error;\n    const _path = path.join('.');\n\n    if (!errors[_path]) {\n      if ('unionErrors' in error) {\n        const unionError = error.unionErrors[0].errors[0];\n\n        errors[_path] = {\n          message: unionError.message,\n          type: unionError.code,\n        };\n      } else {\n        errors[_path] = { message, type: code };\n      }\n    }\n\n    if ('unionErrors' in error) {\n      error.unionErrors.forEach((unionError) =>\n        unionError.errors.forEach((e) => zodErrors.push(e)),\n      );\n    }\n\n    if (validateAllFieldCriteria) {\n      const types = errors[_path].types;\n      const messages = types && types[error.code];\n\n      errors[_path] = appendErrors(\n        _path,\n        validateAllFieldCriteria,\n        errors,\n        code,\n        messages\n          ? ([] as string[]).concat(messages as string[], error.message)\n          : error.message,\n      ) as FieldError;\n    }\n\n    zodErrors.shift();\n  }\n\n  return errors;\n}\n\nfunction parseZod4Issues(\n  zodErrors: z4.$ZodIssue[],\n  validateAllFieldCriteria: boolean,\n) {\n  const errors: Record<string, FieldError> = {};\n  // const _zodErrors = zodErrors as z4.$ZodISsue; //\n  for (; zodErrors.length; ) {\n    const error = zodErrors[0];\n    const { code, message, path } = error;\n    const _path = path.join('.');\n\n    if (!errors[_path]) {\n      if (error.code === 'invalid_union') {\n        const unionError = error.errors[0][0];\n\n        errors[_path] = {\n          message: unionError.message,\n          type: unionError.code,\n        };\n      } else {\n        errors[_path] = { message, type: code };\n      }\n    }\n\n    if (error.code === 'invalid_union') {\n      error.errors.forEach((unionError) =>\n        unionError.forEach((e) => zodErrors.push(e)),\n      );\n    }\n\n    if (validateAllFieldCriteria) {\n      const types = errors[_path].types;\n      const messages = types && types[error.code];\n\n      errors[_path] = appendErrors(\n        _path,\n        validateAllFieldCriteria,\n        errors,\n        code,\n        messages\n          ? ([] as string[]).concat(messages as string[], error.message)\n          : error.message,\n      ) as FieldError;\n    }\n\n    zodErrors.shift();\n  }\n\n  return errors;\n}\n\ntype RawResolverOptions = {\n  mode?: 'async' | 'sync';\n  raw: true;\n};\ntype NonRawResolverOptions = {\n  mode?: 'async' | 'sync';\n  raw?: false;\n};\n\n// minimal interfaces to avoid asssignability issues between versions\ninterface Zod3Type<O = unknown, I = unknown> {\n  _output: O;\n  _input: I;\n  _def: {\n    typeName: string;\n  };\n}\n\n// some type magic to make versions pre-3.25.0 still work\ntype IsUnresolved<T> = PropertyKey extends keyof T ? true : false;\ntype UnresolvedFallback<T, Fallback> = IsUnresolved<typeof z3> extends true\n  ? Fallback\n  : T;\ntype FallbackIssue = {\n  code: string;\n  message: string;\n  path: (string | number)[];\n};\ntype Zod3ParseParams = UnresolvedFallback<\n  z3.ParseParams,\n  // fallback if user is on <3.25.0\n  {\n    path?: (string | number)[];\n    errorMap?: (\n      iss: FallbackIssue,\n      ctx: {\n        defaultError: string;\n        data: any;\n      },\n    ) => { message: string };\n    async?: boolean;\n  }\n>;\ntype Zod4ParseParams = UnresolvedFallback<\n  z4.ParseContext<z4.$ZodIssue>,\n  // fallback if user is on <3.25.0\n  {\n    readonly error?: (\n      iss: FallbackIssue,\n    ) => null | undefined | string | { message: string };\n    readonly reportInput?: boolean;\n    readonly jitless?: boolean;\n  }\n>;\n\nexport function zodResolver<Input extends FieldValues, Context, Output>(\n  schema: Zod3Type<Output, Input>,\n  schemaOptions?: Zod3ParseParams,\n  resolverOptions?: NonRawResolverOptions,\n): Resolver<Input, Context, Output>;\nexport function zodResolver<Input extends FieldValues, Context, Output>(\n  schema: Zod3Type<Output, Input>,\n  schemaOptions: Zod3ParseParams | undefined,\n  resolverOptions: RawResolverOptions,\n): Resolver<Input, Context, Input>;\n// the Zod 4 overloads need to be generic for complicated reasons\nexport function zodResolver<\n  Input extends FieldValues,\n  Context,\n  Output,\n  T extends z4.$ZodType<Output, Input> = z4.$ZodType<Output, Input>,\n>(\n  schema: T,\n  schemaOptions?: Zod4ParseParams, // already partial\n  resolverOptions?: NonRawResolverOptions,\n): Resolver<z4.input<T>, Context, z4.output<T>>;\nexport function zodResolver<\n  Input extends FieldValues,\n  Context,\n  Output,\n  T extends z4.$ZodType<Output, Input> = z4.$ZodType<Output, Input>,\n>(\n  schema: z4.$ZodType<Output, Input>,\n  schemaOptions: Zod4ParseParams | undefined, // already partial\n  resolverOptions: RawResolverOptions,\n): Resolver<z4.input<T>, Context, z4.input<T>>;\n/**\n * Creates a resolver function for react-hook-form that validates form data using a Zod schema\n * @param {z3.ZodSchema<Input>} schema - The Zod schema used to validate the form data\n * @param {Partial<z3.ParseParams>} [schemaOptions] - Optional configuration options for Zod parsing\n * @param {Object} [resolverOptions] - Optional resolver-specific configuration\n * @param {('async'|'sync')} [resolverOptions.mode='async'] - Validation mode. Use 'sync' for synchronous validation\n * @param {boolean} [resolverOptions.raw=false] - If true, returns the raw form values instead of the parsed data\n * @returns {Resolver<z3.output<typeof schema>>} A resolver function compatible with react-hook-form\n * @throws {Error} Throws if validation fails with a non-Zod error\n * @example\n * const schema = z3.object({\n *   name: z3.string().min(2),\n *   age: z3.number().min(18)\n * });\n *\n * useForm({\n *   resolver: zodResolver(schema)\n * });\n */\nexport function zodResolver<Input extends FieldValues, Context, Output>(\n  schema: object,\n  schemaOptions?: object,\n  resolverOptions: {\n    mode?: 'async' | 'sync';\n    raw?: boolean;\n  } = {},\n): Resolver<Input, Context, Output | Input> {\n  if (isZod3Schema(schema)) {\n    return async (values: Input, _, options) => {\n      try {\n        const data = await schema[\n          resolverOptions.mode === 'sync' ? 'parse' : 'parseAsync'\n        ](values, schemaOptions);\n\n        options.shouldUseNativeValidation &&\n          validateFieldsNatively({}, options);\n\n        return {\n          errors: {} as FieldErrors,\n          values: resolverOptions.raw ? Object.assign({}, values) : data,\n        } satisfies ResolverSuccess<Output | Input>;\n      } catch (error) {\n        if (isZod3Error(error)) {\n          return {\n            values: {},\n            errors: toNestErrors(\n              parseZod3Issues(\n                error.errors,\n                !options.shouldUseNativeValidation &&\n                  options.criteriaMode === 'all',\n              ),\n              options,\n            ),\n          } satisfies ResolverError<Input>;\n        }\n\n        throw error;\n      }\n    };\n  }\n\n  if (isZod4Schema(schema)) {\n    return async (values: Input, _, options) => {\n      try {\n        const parseFn =\n          resolverOptions.mode === 'sync' ? z4.parse : z4.parseAsync;\n        const data: any = await parseFn(schema, values, schemaOptions);\n\n        options.shouldUseNativeValidation &&\n          validateFieldsNatively({}, options);\n\n        return {\n          errors: {} as FieldErrors,\n          values: resolverOptions.raw ? Object.assign({}, values) : data,\n        } satisfies ResolverSuccess<Output | Input>;\n      } catch (error) {\n        if (isZod4Error(error)) {\n          return {\n            values: {},\n            errors: toNestErrors(\n              parseZod4Issues(\n                error.issues,\n                !options.shouldUseNativeValidation &&\n                  options.criteriaMode === 'all',\n              ),\n              options,\n            ),\n          } satisfies ResolverError<Input>;\n        }\n\n        throw error;\n      }\n    };\n  }\n\n  throw new Error('Invalid input: not a Zod schema');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}