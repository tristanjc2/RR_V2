{"ast":null,"code":"import _objectSpread from \"C:/RR_V3/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { $ZodRegistry, globalRegistry } from \"./registries.js\";\nimport { getEnumValues } from \"./util.js\";\nexport class JSONSchemaGenerator {\n  constructor(params) {\n    var _params$metadata, _params$target, _params$unrepresentab, _params$override, _params$io;\n    this.counter = 0;\n    this.metadataRegistry = (_params$metadata = params === null || params === void 0 ? void 0 : params.metadata) !== null && _params$metadata !== void 0 ? _params$metadata : globalRegistry;\n    this.target = (_params$target = params === null || params === void 0 ? void 0 : params.target) !== null && _params$target !== void 0 ? _params$target : \"draft-2020-12\";\n    this.unrepresentable = (_params$unrepresentab = params === null || params === void 0 ? void 0 : params.unrepresentable) !== null && _params$unrepresentab !== void 0 ? _params$unrepresentab : \"throw\";\n    this.override = (_params$override = params === null || params === void 0 ? void 0 : params.override) !== null && _params$override !== void 0 ? _params$override : () => {};\n    this.io = (_params$io = params === null || params === void 0 ? void 0 : params.io) !== null && _params$io !== void 0 ? _params$io : \"output\";\n    this.seen = new Map();\n  }\n  process(schema) {\n    var _schema$_zod$toJSONSc, _schema$_zod, _a$default;\n    let _params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      path: [],\n      schemaPath: []\n    };\n    var _a;\n    const def = schema._zod.def;\n    const formatMap = {\n      guid: \"uuid\",\n      url: \"uri\",\n      datetime: \"date-time\",\n      json_string: \"json-string\",\n      regex: \"\" // do not set\n    };\n    // check for schema in seens\n    const seen = this.seen.get(schema);\n    if (seen) {\n      seen.count++;\n      // check if cycle\n      const isCycle = _params.schemaPath.includes(schema);\n      if (isCycle) {\n        seen.cycle = _params.path;\n      }\n      return seen.schema;\n    }\n    // initialize\n    const result = {\n      schema: {},\n      count: 1,\n      cycle: undefined\n    };\n    this.seen.set(schema, result);\n    // custom method overrides default behavior\n    const overrideSchema = (_schema$_zod$toJSONSc = (_schema$_zod = schema._zod).toJSONSchema) === null || _schema$_zod$toJSONSc === void 0 ? void 0 : _schema$_zod$toJSONSc.call(_schema$_zod);\n    if (overrideSchema) {\n      result.schema = overrideSchema;\n    } else {\n      const params = _objectSpread(_objectSpread({}, _params), {}, {\n        schemaPath: [..._params.schemaPath, schema],\n        path: _params.path\n      });\n      const parent = schema._zod.parent;\n      if (parent) {\n        // schema was cloned from another schema\n        result.ref = parent;\n        this.process(parent, params);\n        this.seen.get(parent).isParent = true;\n      } else {\n        const _json = result.schema;\n        switch (def.type) {\n          case \"string\":\n            {\n              const json = _json;\n              json.type = \"string\";\n              const {\n                minimum,\n                maximum,\n                format,\n                patterns,\n                contentEncoding\n              } = schema._zod.bag;\n              if (typeof minimum === \"number\") json.minLength = minimum;\n              if (typeof maximum === \"number\") json.maxLength = maximum;\n              // custom pattern overrides format\n              if (format) {\n                var _formatMap$format;\n                json.format = (_formatMap$format = formatMap[format]) !== null && _formatMap$format !== void 0 ? _formatMap$format : format;\n                if (json.format === \"\") delete json.format; // empty format is not valid\n              }\n              if (contentEncoding) json.contentEncoding = contentEncoding;\n              if (patterns && patterns.size > 0) {\n                const regexes = [...patterns];\n                if (regexes.length === 1) json.pattern = regexes[0].source;else if (regexes.length > 1) {\n                  result.schema.allOf = [...regexes.map(regex => _objectSpread(_objectSpread({}, this.target === \"draft-7\" ? {\n                    type: \"string\"\n                  } : {}), {}, {\n                    pattern: regex.source\n                  }))];\n                }\n              }\n              break;\n            }\n          case \"number\":\n            {\n              const json = _json;\n              const {\n                minimum,\n                maximum,\n                format,\n                multipleOf,\n                exclusiveMaximum,\n                exclusiveMinimum\n              } = schema._zod.bag;\n              if (typeof format === \"string\" && format.includes(\"int\")) json.type = \"integer\";else json.type = \"number\";\n              if (typeof exclusiveMinimum === \"number\") json.exclusiveMinimum = exclusiveMinimum;\n              if (typeof minimum === \"number\") {\n                json.minimum = minimum;\n                if (typeof exclusiveMinimum === \"number\") {\n                  if (exclusiveMinimum >= minimum) delete json.minimum;else delete json.exclusiveMinimum;\n                }\n              }\n              if (typeof exclusiveMaximum === \"number\") json.exclusiveMaximum = exclusiveMaximum;\n              if (typeof maximum === \"number\") {\n                json.maximum = maximum;\n                if (typeof exclusiveMaximum === \"number\") {\n                  if (exclusiveMaximum <= maximum) delete json.maximum;else delete json.exclusiveMaximum;\n                }\n              }\n              if (typeof multipleOf === \"number\") json.multipleOf = multipleOf;\n              break;\n            }\n          case \"boolean\":\n            {\n              const json = _json;\n              json.type = \"boolean\";\n              break;\n            }\n          case \"bigint\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"BigInt cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"symbol\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Symbols cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"undefined\":\n            {\n              const json = _json;\n              json.type = \"null\";\n              break;\n            }\n          case \"null\":\n            {\n              _json.type = \"null\";\n              break;\n            }\n          case \"any\":\n            {\n              break;\n            }\n          case \"unknown\":\n            {\n              break;\n            }\n          case \"never\":\n            {\n              _json.not = {};\n              break;\n            }\n          case \"void\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Void cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"date\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Date cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"array\":\n            {\n              const json = _json;\n              const {\n                minimum,\n                maximum\n              } = schema._zod.bag;\n              if (typeof minimum === \"number\") json.minItems = minimum;\n              if (typeof maximum === \"number\") json.maxItems = maximum;\n              json.type = \"array\";\n              json.items = this.process(def.element, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"items\"]\n              }));\n              break;\n            }\n          case \"object\":\n            {\n              var _def$catchall;\n              const json = _json;\n              json.type = \"object\";\n              json.properties = {};\n              const shape = def.shape; // params.shapeCache.get(schema)!;\n              for (const key in shape) {\n                json.properties[key] = this.process(shape[key], _objectSpread(_objectSpread({}, params), {}, {\n                  path: [...params.path, \"properties\", key]\n                }));\n              }\n              // required keys\n              const allKeys = new Set(Object.keys(shape));\n              // const optionalKeys = new Set(def.optional);\n              const requiredKeys = new Set([...allKeys].filter(key => {\n                const v = def.shape[key]._zod;\n                if (this.io === \"input\") {\n                  return v.optin === undefined;\n                } else {\n                  return v.optout === undefined;\n                }\n              }));\n              if (requiredKeys.size > 0) {\n                json.required = Array.from(requiredKeys);\n              }\n              // catchall\n              if (((_def$catchall = def.catchall) === null || _def$catchall === void 0 ? void 0 : _def$catchall._zod.def.type) === \"never\") {\n                // strict\n                json.additionalProperties = false;\n              } else if (!def.catchall) {\n                // regular\n                if (this.io === \"output\") json.additionalProperties = false;\n              } else if (def.catchall) {\n                json.additionalProperties = this.process(def.catchall, _objectSpread(_objectSpread({}, params), {}, {\n                  path: [...params.path, \"additionalProperties\"]\n                }));\n              }\n              break;\n            }\n          case \"union\":\n            {\n              const json = _json;\n              json.anyOf = def.options.map((x, i) => this.process(x, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"anyOf\", i]\n              })));\n              break;\n            }\n          case \"intersection\":\n            {\n              const json = _json;\n              const a = this.process(def.left, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"allOf\", 0]\n              }));\n              const b = this.process(def.right, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"allOf\", 1]\n              }));\n              const isSimpleIntersection = val => \"allOf\" in val && Object.keys(val).length === 1;\n              const allOf = [...(isSimpleIntersection(a) ? a.allOf : [a]), ...(isSimpleIntersection(b) ? b.allOf : [b])];\n              json.allOf = allOf;\n              break;\n            }\n          case \"tuple\":\n            {\n              const json = _json;\n              json.type = \"array\";\n              const prefixItems = def.items.map((x, i) => this.process(x, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"prefixItems\", i]\n              })));\n              if (this.target === \"draft-2020-12\") {\n                json.prefixItems = prefixItems;\n              } else {\n                json.items = prefixItems;\n              }\n              if (def.rest) {\n                const rest = this.process(def.rest, _objectSpread(_objectSpread({}, params), {}, {\n                  path: [...params.path, \"items\"]\n                }));\n                if (this.target === \"draft-2020-12\") {\n                  json.items = rest;\n                } else {\n                  json.additionalItems = rest;\n                }\n              }\n              // additionalItems\n              if (def.rest) {\n                json.items = this.process(def.rest, _objectSpread(_objectSpread({}, params), {}, {\n                  path: [...params.path, \"items\"]\n                }));\n              }\n              // length\n              const {\n                minimum,\n                maximum\n              } = schema._zod.bag;\n              if (typeof minimum === \"number\") json.minItems = minimum;\n              if (typeof maximum === \"number\") json.maxItems = maximum;\n              break;\n            }\n          case \"record\":\n            {\n              const json = _json;\n              json.type = \"object\";\n              json.propertyNames = this.process(def.keyType, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"propertyNames\"]\n              }));\n              json.additionalProperties = this.process(def.valueType, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"additionalProperties\"]\n              }));\n              break;\n            }\n          case \"map\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Map cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"set\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Set cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"enum\":\n            {\n              const json = _json;\n              const values = getEnumValues(def.entries);\n              // Number enums can have both string and number values\n              if (values.every(v => typeof v === \"number\")) json.type = \"number\";\n              if (values.every(v => typeof v === \"string\")) json.type = \"string\";\n              json.enum = values;\n              break;\n            }\n          case \"literal\":\n            {\n              const json = _json;\n              const vals = [];\n              for (const val of def.values) {\n                if (val === undefined) {\n                  if (this.unrepresentable === \"throw\") {\n                    throw new Error(\"Literal `undefined` cannot be represented in JSON Schema\");\n                  } else {\n                    // do not add to vals\n                  }\n                } else if (typeof val === \"bigint\") {\n                  if (this.unrepresentable === \"throw\") {\n                    throw new Error(\"BigInt literals cannot be represented in JSON Schema\");\n                  } else {\n                    vals.push(Number(val));\n                  }\n                } else {\n                  vals.push(val);\n                }\n              }\n              if (vals.length === 0) {\n                // do nothing (an undefined literal was stripped)\n              } else if (vals.length === 1) {\n                const val = vals[0];\n                json.type = val === null ? \"null\" : typeof val;\n                json.const = val;\n              } else {\n                if (vals.every(v => typeof v === \"number\")) json.type = \"number\";\n                if (vals.every(v => typeof v === \"string\")) json.type = \"string\";\n                if (vals.every(v => typeof v === \"boolean\")) json.type = \"string\";\n                if (vals.every(v => v === null)) json.type = \"null\";\n                json.enum = vals;\n              }\n              break;\n            }\n          case \"file\":\n            {\n              const json = _json;\n              const file = {\n                type: \"string\",\n                format: \"binary\",\n                contentEncoding: \"binary\"\n              };\n              const {\n                minimum,\n                maximum,\n                mime\n              } = schema._zod.bag;\n              if (minimum !== undefined) file.minLength = minimum;\n              if (maximum !== undefined) file.maxLength = maximum;\n              if (mime) {\n                if (mime.length === 1) {\n                  file.contentMediaType = mime[0];\n                  Object.assign(json, file);\n                } else {\n                  json.anyOf = mime.map(m => {\n                    const mFile = _objectSpread(_objectSpread({}, file), {}, {\n                      contentMediaType: m\n                    });\n                    return mFile;\n                  });\n                }\n              } else {\n                Object.assign(json, file);\n              }\n              // if (this.unrepresentable === \"throw\") {\n              //   throw new Error(\"File cannot be represented in JSON Schema\");\n              // }\n              break;\n            }\n          case \"transform\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Transforms cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"nullable\":\n            {\n              const inner = this.process(def.innerType, params);\n              _json.anyOf = [inner, {\n                type: \"null\"\n              }];\n              break;\n            }\n          case \"nonoptional\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              break;\n            }\n          case \"success\":\n            {\n              const json = _json;\n              json.type = \"boolean\";\n              break;\n            }\n          case \"default\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              _json.default = JSON.parse(JSON.stringify(def.defaultValue));\n              break;\n            }\n          case \"prefault\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              if (this.io === \"input\") _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));\n              break;\n            }\n          case \"catch\":\n            {\n              // use conditionals\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              let catchValue;\n              try {\n                catchValue = def.catchValue(undefined);\n              } catch (_unused) {\n                throw new Error(\"Dynamic catch values are not supported in JSON Schema\");\n              }\n              _json.default = catchValue;\n              break;\n            }\n          case \"nan\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"NaN cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"template_literal\":\n            {\n              const json = _json;\n              const pattern = schema._zod.pattern;\n              if (!pattern) throw new Error(\"Pattern not found in template literal\");\n              json.type = \"string\";\n              json.pattern = pattern.source;\n              break;\n            }\n          case \"pipe\":\n            {\n              const innerType = this.io === \"input\" ? def.in._zod.def.type === \"transform\" ? def.out : def.in : def.out;\n              this.process(innerType, params);\n              result.ref = innerType;\n              break;\n            }\n          case \"readonly\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              _json.readOnly = true;\n              break;\n            }\n          // passthrough types\n          case \"promise\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              break;\n            }\n          case \"optional\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              break;\n            }\n          case \"lazy\":\n            {\n              const innerType = schema._zod.innerType;\n              this.process(innerType, params);\n              result.ref = innerType;\n              break;\n            }\n          case \"custom\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Custom types cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          default:\n            {\n              def;\n            }\n        }\n      }\n    }\n    // metadata\n    const meta = this.metadataRegistry.get(schema);\n    if (meta) Object.assign(result.schema, meta);\n    if (this.io === \"input\" && isTransforming(schema)) {\n      // examples/defaults only apply to output type of pipe\n      delete result.schema.examples;\n      delete result.schema.default;\n    }\n    // set prefault as default\n    if (this.io === \"input\" && result.schema._prefault) (_a$default = (_a = result.schema).default) !== null && _a$default !== void 0 ? _a$default : _a.default = result.schema._prefault;\n    delete result.schema._prefault;\n    // pulling fresh from this.seen in case it was overwritten\n    const _result = this.seen.get(schema);\n    return _result.schema;\n  }\n  emit(schema, _params) {\n    var _params$cycles, _params$reused, _params$external, _params$external$defs, _params$external2;\n    const params = {\n      cycles: (_params$cycles = _params === null || _params === void 0 ? void 0 : _params.cycles) !== null && _params$cycles !== void 0 ? _params$cycles : \"ref\",\n      reused: (_params$reused = _params === null || _params === void 0 ? void 0 : _params.reused) !== null && _params$reused !== void 0 ? _params$reused : \"inline\",\n      // unrepresentable: _params?.unrepresentable ?? \"throw\",\n      // uri: _params?.uri ?? ((id) => `${id}`),\n      external: (_params$external = _params === null || _params === void 0 ? void 0 : _params.external) !== null && _params$external !== void 0 ? _params$external : undefined\n    };\n    // iterate over seen map;\n    const root = this.seen.get(schema);\n    if (!root) throw new Error(\"Unprocessed schema. This is a bug in Zod.\");\n    // initialize result with root schema fields\n    // Object.assign(result, seen.cached);\n    const makeURI = entry => {\n      var _entry$1$schema$id;\n      // comparing the seen objects because sometimes\n      // multiple schemas map to the same seen object.\n      // e.g. lazy\n      // external is configured\n      const defsSegment = this.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      if (params.external) {\n        var _params$external$regi, _ref, _entry$1$defId;\n        const externalId = (_params$external$regi = params.external.registry.get(entry[0])) === null || _params$external$regi === void 0 ? void 0 : _params$external$regi.id; // ?? \"__shared\";// `__schema${this.counter++}`;\n        // check if schema is in the external registry\n        if (externalId) return {\n          ref: params.external.uri(externalId)\n        };\n        // otherwise, add to __shared\n        const id = (_ref = (_entry$1$defId = entry[1].defId) !== null && _entry$1$defId !== void 0 ? _entry$1$defId : entry[1].schema.id) !== null && _ref !== void 0 ? _ref : \"schema\".concat(this.counter++);\n        entry[1].defId = id;\n        return {\n          defId: id,\n          ref: \"\".concat(params.external.uri(\"__shared\"), \"#/\").concat(defsSegment, \"/\").concat(id)\n        };\n      }\n      if (entry[1] === root) {\n        return {\n          ref: \"#\"\n        };\n      }\n      // self-contained schema\n      const uriPrefix = \"#\";\n      const defUriPrefix = \"\".concat(uriPrefix, \"/\").concat(defsSegment, \"/\");\n      const defId = (_entry$1$schema$id = entry[1].schema.id) !== null && _entry$1$schema$id !== void 0 ? _entry$1$schema$id : \"__schema\".concat(this.counter++);\n      return {\n        defId,\n        ref: defUriPrefix + defId\n      };\n    };\n    // stored cached version in `def` property\n    // remove all properties, set $ref\n    const extractToDef = entry => {\n      if (entry[1].schema.$ref) {\n        return;\n      }\n      const seen = entry[1];\n      const {\n        ref,\n        defId\n      } = makeURI(entry);\n      seen.def = _objectSpread({}, seen.schema);\n      // defId won't be set if the schema is a reference to an external schema\n      if (defId) seen.defId = defId;\n      // wipe away all properties except $ref\n      const schema = seen.schema;\n      for (const key in schema) {\n        delete schema[key];\n      }\n      schema.$ref = ref;\n    };\n    // extract schemas into $defs\n    for (const entry of this.seen.entries()) {\n      var _this$metadataRegistr;\n      const seen = entry[1];\n      // convert root schema to # $ref\n      // also prevents root schema from being extracted\n      if (schema === entry[0]) {\n        // do not copy to defs...this is the root schema\n        extractToDef(entry);\n        continue;\n      }\n      // extract schemas that are in the external registry\n      if (params.external) {\n        var _params$external$regi2;\n        const ext = (_params$external$regi2 = params.external.registry.get(entry[0])) === null || _params$external$regi2 === void 0 ? void 0 : _params$external$regi2.id;\n        if (schema !== entry[0] && ext) {\n          extractToDef(entry);\n          continue;\n        }\n      }\n      // extract schemas with `id` meta\n      const id = (_this$metadataRegistr = this.metadataRegistry.get(entry[0])) === null || _this$metadataRegistr === void 0 ? void 0 : _this$metadataRegistr.id;\n      if (id) {\n        extractToDef(entry);\n        continue;\n      }\n      // break cycles\n      if (seen.cycle) {\n        if (params.cycles === \"throw\") {\n          var _seen$cycle;\n          throw new Error(\"Cycle detected: \" + \"#/\".concat((_seen$cycle = seen.cycle) === null || _seen$cycle === void 0 ? void 0 : _seen$cycle.join(\"/\"), \"/<root>\") + '\\n\\nSet the `cycles` parameter to `\"ref\"` to resolve cyclical schemas with defs.');\n        } else if (params.cycles === \"ref\") {\n          extractToDef(entry);\n        }\n        continue;\n      }\n      // extract reused schemas\n      if (seen.count > 1) {\n        if (params.reused === \"ref\") {\n          extractToDef(entry);\n          // biome-ignore lint:\n          continue;\n        }\n      }\n    }\n    // flatten _refs\n    const flattenRef = (zodSchema, params) => {\n      var _seen$def;\n      const seen = this.seen.get(zodSchema);\n      const schema = (_seen$def = seen.def) !== null && _seen$def !== void 0 ? _seen$def : seen.schema;\n      const _cached = _objectSpread({}, schema);\n      // already seen\n      if (seen.ref === null) {\n        return;\n      }\n      // flatten ref if defined\n      const ref = seen.ref;\n      seen.ref = null; // prevent recursion\n      if (ref) {\n        flattenRef(ref, params);\n        // merge referenced schema into current\n        const refSchema = this.seen.get(ref).schema;\n        if (refSchema.$ref && params.target === \"draft-7\") {\n          var _schema$allOf;\n          schema.allOf = (_schema$allOf = schema.allOf) !== null && _schema$allOf !== void 0 ? _schema$allOf : [];\n          schema.allOf.push(refSchema);\n        } else {\n          Object.assign(schema, refSchema);\n          Object.assign(schema, _cached); // prevent overwriting any fields in the original schema\n        }\n      }\n      // execute overrides\n      if (!seen.isParent) this.override({\n        zodSchema: zodSchema,\n        jsonSchema: schema\n      });\n    };\n    for (const entry of [...this.seen.entries()].reverse()) {\n      flattenRef(entry[0], {\n        target: this.target\n      });\n    }\n    const result = {};\n    if (this.target === \"draft-2020-12\") {\n      result.$schema = \"https://json-schema.org/draft/2020-12/schema\";\n    } else if (this.target === \"draft-7\") {\n      result.$schema = \"http://json-schema.org/draft-07/schema#\";\n    } else {\n      console.warn(\"Invalid target: \".concat(this.target));\n    }\n    Object.assign(result, root.def);\n    // build defs object\n    const defs = (_params$external$defs = (_params$external2 = params.external) === null || _params$external2 === void 0 ? void 0 : _params$external2.defs) !== null && _params$external$defs !== void 0 ? _params$external$defs : {};\n    for (const entry of this.seen.entries()) {\n      const seen = entry[1];\n      if (seen.def && seen.defId) {\n        defs[seen.defId] = seen.def;\n      }\n    }\n    // set definitions in result\n    if (!params.external && Object.keys(defs).length > 0) {\n      if (this.target === \"draft-2020-12\") {\n        result.$defs = defs;\n      } else {\n        result.definitions = defs;\n      }\n    }\n    try {\n      // this \"finalizes\" this schema and ensures all cycles are removed\n      // each call to .emit() is functionally independent\n      // though the seen map is shared\n      return JSON.parse(JSON.stringify(result));\n    } catch (_err) {\n      throw new Error(\"Error converting schema to JSON.\");\n    }\n  }\n}\nexport function toJSONSchema(input, _params) {\n  if (input instanceof $ZodRegistry) {\n    const gen = new JSONSchemaGenerator(_params);\n    const defs = {};\n    for (const entry of input._idmap.entries()) {\n      const [_, schema] = entry;\n      gen.process(schema);\n    }\n    const schemas = {};\n    const external = {\n      registry: input,\n      uri: (_params === null || _params === void 0 ? void 0 : _params.uri) || (id => id),\n      defs\n    };\n    for (const entry of input._idmap.entries()) {\n      const [key, schema] = entry;\n      schemas[key] = gen.emit(schema, _objectSpread(_objectSpread({}, _params), {}, {\n        external\n      }));\n    }\n    if (Object.keys(defs).length > 0) {\n      const defsSegment = gen.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      schemas.__shared = {\n        [defsSegment]: defs\n      };\n    }\n    return {\n      schemas\n    };\n  }\n  const gen = new JSONSchemaGenerator(_params);\n  gen.process(input);\n  return gen.emit(input, _params);\n}\nfunction isTransforming(_schema, _ctx) {\n  const ctx = _ctx !== null && _ctx !== void 0 ? _ctx : {\n    seen: new Set()\n  };\n  if (ctx.seen.has(_schema)) return false;\n  ctx.seen.add(_schema);\n  const schema = _schema;\n  const def = schema._zod.def;\n  switch (def.type) {\n    case \"string\":\n    case \"number\":\n    case \"bigint\":\n    case \"boolean\":\n    case \"date\":\n    case \"symbol\":\n    case \"undefined\":\n    case \"null\":\n    case \"any\":\n    case \"unknown\":\n    case \"never\":\n    case \"void\":\n    case \"literal\":\n    case \"enum\":\n    case \"nan\":\n    case \"file\":\n    case \"template_literal\":\n      return false;\n    case \"array\":\n      {\n        return isTransforming(def.element, ctx);\n      }\n    case \"object\":\n      {\n        for (const key in def.shape) {\n          if (isTransforming(def.shape[key], ctx)) return true;\n        }\n        return false;\n      }\n    case \"union\":\n      {\n        for (const option of def.options) {\n          if (isTransforming(option, ctx)) return true;\n        }\n        return false;\n      }\n    case \"intersection\":\n      {\n        return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);\n      }\n    case \"tuple\":\n      {\n        for (const item of def.items) {\n          if (isTransforming(item, ctx)) return true;\n        }\n        if (def.rest && isTransforming(def.rest, ctx)) return true;\n        return false;\n      }\n    case \"record\":\n      {\n        return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n      }\n    case \"map\":\n      {\n        return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n      }\n    case \"set\":\n      {\n        return isTransforming(def.valueType, ctx);\n      }\n    // inner types\n    case \"promise\":\n    case \"optional\":\n    case \"nonoptional\":\n    case \"nullable\":\n    case \"readonly\":\n      return isTransforming(def.innerType, ctx);\n    case \"lazy\":\n      return isTransforming(def.getter(), ctx);\n    case \"default\":\n      {\n        return isTransforming(def.innerType, ctx);\n      }\n    case \"prefault\":\n      {\n        return isTransforming(def.innerType, ctx);\n      }\n    case \"custom\":\n      {\n        return false;\n      }\n    case \"transform\":\n      {\n        return true;\n      }\n    case \"pipe\":\n      {\n        return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);\n      }\n    case \"success\":\n      {\n        return false;\n      }\n    case \"catch\":\n      {\n        return false;\n      }\n    default:\n      def;\n  }\n  throw new Error(\"Unknown schema type: \".concat(def.type));\n}","map":{"version":3,"names":["$ZodRegistry","globalRegistry","getEnumValues","JSONSchemaGenerator","constructor","params","_params$metadata","_params$target","_params$unrepresentab","_params$override","_params$io","counter","metadataRegistry","metadata","target","unrepresentable","override","io","seen","Map","process","schema","_schema$_zod$toJSONSc","_schema$_zod","_a$default","_params","arguments","length","undefined","path","schemaPath","_a","def","_zod","formatMap","guid","url","datetime","json_string","regex","get","count","isCycle","includes","cycle","result","set","overrideSchema","toJSONSchema","call","_objectSpread","parent","ref","isParent","_json","type","json","minimum","maximum","format","patterns","contentEncoding","bag","minLength","maxLength","_formatMap$format","size","regexes","pattern","source","allOf","map","multipleOf","exclusiveMaximum","exclusiveMinimum","Error","not","minItems","maxItems","items","element","_def$catchall","properties","shape","key","allKeys","Set","Object","keys","requiredKeys","filter","v","optin","optout","required","Array","from","catchall","additionalProperties","anyOf","options","x","i","a","left","b","right","isSimpleIntersection","val","prefixItems","rest","additionalItems","propertyNames","keyType","valueType","values","entries","every","enum","vals","push","Number","const","file","mime","contentMediaType","assign","m","mFile","inner","innerType","default","JSON","parse","stringify","defaultValue","_prefault","catchValue","_unused","in","out","readOnly","meta","isTransforming","examples","_result","emit","_params$cycles","_params$reused","_params$external","_params$external$defs","_params$external2","cycles","reused","external","root","makeURI","entry","_entry$1$schema$id","defsSegment","_params$external$regi","_ref","_entry$1$defId","externalId","registry","id","uri","defId","concat","uriPrefix","defUriPrefix","extractToDef","$ref","_this$metadataRegistr","_params$external$regi2","ext","_seen$cycle","join","flattenRef","zodSchema","_seen$def","_cached","refSchema","_schema$allOf","jsonSchema","reverse","$schema","console","warn","defs","$defs","definitions","_err","input","gen","_idmap","_","schemas","__shared","_schema","_ctx","ctx","has","add","option","item","getter"],"sources":["C:/RR_V3/node_modules/zod/dist/esm/v4/core/to-json-schema.js"],"sourcesContent":["import { $ZodRegistry, globalRegistry } from \"./registries.js\";\nimport { getEnumValues } from \"./util.js\";\nexport class JSONSchemaGenerator {\n    constructor(params) {\n        this.counter = 0;\n        this.metadataRegistry = params?.metadata ?? globalRegistry;\n        this.target = params?.target ?? \"draft-2020-12\";\n        this.unrepresentable = params?.unrepresentable ?? \"throw\";\n        this.override = params?.override ?? (() => { });\n        this.io = params?.io ?? \"output\";\n        this.seen = new Map();\n    }\n    process(schema, _params = { path: [], schemaPath: [] }) {\n        var _a;\n        const def = schema._zod.def;\n        const formatMap = {\n            guid: \"uuid\",\n            url: \"uri\",\n            datetime: \"date-time\",\n            json_string: \"json-string\",\n            regex: \"\", // do not set\n        };\n        // check for schema in seens\n        const seen = this.seen.get(schema);\n        if (seen) {\n            seen.count++;\n            // check if cycle\n            const isCycle = _params.schemaPath.includes(schema);\n            if (isCycle) {\n                seen.cycle = _params.path;\n            }\n            return seen.schema;\n        }\n        // initialize\n        const result = { schema: {}, count: 1, cycle: undefined };\n        this.seen.set(schema, result);\n        // custom method overrides default behavior\n        const overrideSchema = schema._zod.toJSONSchema?.();\n        if (overrideSchema) {\n            result.schema = overrideSchema;\n        }\n        else {\n            const params = {\n                ..._params,\n                schemaPath: [..._params.schemaPath, schema],\n                path: _params.path,\n            };\n            const parent = schema._zod.parent;\n            if (parent) {\n                // schema was cloned from another schema\n                result.ref = parent;\n                this.process(parent, params);\n                this.seen.get(parent).isParent = true;\n            }\n            else {\n                const _json = result.schema;\n                switch (def.type) {\n                    case \"string\": {\n                        const json = _json;\n                        json.type = \"string\";\n                        const { minimum, maximum, format, patterns, contentEncoding } = schema._zod\n                            .bag;\n                        if (typeof minimum === \"number\")\n                            json.minLength = minimum;\n                        if (typeof maximum === \"number\")\n                            json.maxLength = maximum;\n                        // custom pattern overrides format\n                        if (format) {\n                            json.format = formatMap[format] ?? format;\n                            if (json.format === \"\")\n                                delete json.format; // empty format is not valid\n                        }\n                        if (contentEncoding)\n                            json.contentEncoding = contentEncoding;\n                        if (patterns && patterns.size > 0) {\n                            const regexes = [...patterns];\n                            if (regexes.length === 1)\n                                json.pattern = regexes[0].source;\n                            else if (regexes.length > 1) {\n                                result.schema.allOf = [\n                                    ...regexes.map((regex) => ({\n                                        ...(this.target === \"draft-7\" ? { type: \"string\" } : {}),\n                                        pattern: regex.source,\n                                    })),\n                                ];\n                            }\n                        }\n                        break;\n                    }\n                    case \"number\": {\n                        const json = _json;\n                        const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;\n                        if (typeof format === \"string\" && format.includes(\"int\"))\n                            json.type = \"integer\";\n                        else\n                            json.type = \"number\";\n                        if (typeof exclusiveMinimum === \"number\")\n                            json.exclusiveMinimum = exclusiveMinimum;\n                        if (typeof minimum === \"number\") {\n                            json.minimum = minimum;\n                            if (typeof exclusiveMinimum === \"number\") {\n                                if (exclusiveMinimum >= minimum)\n                                    delete json.minimum;\n                                else\n                                    delete json.exclusiveMinimum;\n                            }\n                        }\n                        if (typeof exclusiveMaximum === \"number\")\n                            json.exclusiveMaximum = exclusiveMaximum;\n                        if (typeof maximum === \"number\") {\n                            json.maximum = maximum;\n                            if (typeof exclusiveMaximum === \"number\") {\n                                if (exclusiveMaximum <= maximum)\n                                    delete json.maximum;\n                                else\n                                    delete json.exclusiveMaximum;\n                            }\n                        }\n                        if (typeof multipleOf === \"number\")\n                            json.multipleOf = multipleOf;\n                        break;\n                    }\n                    case \"boolean\": {\n                        const json = _json;\n                        json.type = \"boolean\";\n                        break;\n                    }\n                    case \"bigint\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"BigInt cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"symbol\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Symbols cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"undefined\": {\n                        const json = _json;\n                        json.type = \"null\";\n                        break;\n                    }\n                    case \"null\": {\n                        _json.type = \"null\";\n                        break;\n                    }\n                    case \"any\": {\n                        break;\n                    }\n                    case \"unknown\": {\n                        break;\n                    }\n                    case \"never\": {\n                        _json.not = {};\n                        break;\n                    }\n                    case \"void\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Void cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"date\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Date cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"array\": {\n                        const json = _json;\n                        const { minimum, maximum } = schema._zod.bag;\n                        if (typeof minimum === \"number\")\n                            json.minItems = minimum;\n                        if (typeof maximum === \"number\")\n                            json.maxItems = maximum;\n                        json.type = \"array\";\n                        json.items = this.process(def.element, { ...params, path: [...params.path, \"items\"] });\n                        break;\n                    }\n                    case \"object\": {\n                        const json = _json;\n                        json.type = \"object\";\n                        json.properties = {};\n                        const shape = def.shape; // params.shapeCache.get(schema)!;\n                        for (const key in shape) {\n                            json.properties[key] = this.process(shape[key], {\n                                ...params,\n                                path: [...params.path, \"properties\", key],\n                            });\n                        }\n                        // required keys\n                        const allKeys = new Set(Object.keys(shape));\n                        // const optionalKeys = new Set(def.optional);\n                        const requiredKeys = new Set([...allKeys].filter((key) => {\n                            const v = def.shape[key]._zod;\n                            if (this.io === \"input\") {\n                                return v.optin === undefined;\n                            }\n                            else {\n                                return v.optout === undefined;\n                            }\n                        }));\n                        if (requiredKeys.size > 0) {\n                            json.required = Array.from(requiredKeys);\n                        }\n                        // catchall\n                        if (def.catchall?._zod.def.type === \"never\") {\n                            // strict\n                            json.additionalProperties = false;\n                        }\n                        else if (!def.catchall) {\n                            // regular\n                            if (this.io === \"output\")\n                                json.additionalProperties = false;\n                        }\n                        else if (def.catchall) {\n                            json.additionalProperties = this.process(def.catchall, {\n                                ...params,\n                                path: [...params.path, \"additionalProperties\"],\n                            });\n                        }\n                        break;\n                    }\n                    case \"union\": {\n                        const json = _json;\n                        json.anyOf = def.options.map((x, i) => this.process(x, {\n                            ...params,\n                            path: [...params.path, \"anyOf\", i],\n                        }));\n                        break;\n                    }\n                    case \"intersection\": {\n                        const json = _json;\n                        const a = this.process(def.left, {\n                            ...params,\n                            path: [...params.path, \"allOf\", 0],\n                        });\n                        const b = this.process(def.right, {\n                            ...params,\n                            path: [...params.path, \"allOf\", 1],\n                        });\n                        const isSimpleIntersection = (val) => \"allOf\" in val && Object.keys(val).length === 1;\n                        const allOf = [\n                            ...(isSimpleIntersection(a) ? a.allOf : [a]),\n                            ...(isSimpleIntersection(b) ? b.allOf : [b]),\n                        ];\n                        json.allOf = allOf;\n                        break;\n                    }\n                    case \"tuple\": {\n                        const json = _json;\n                        json.type = \"array\";\n                        const prefixItems = def.items.map((x, i) => this.process(x, { ...params, path: [...params.path, \"prefixItems\", i] }));\n                        if (this.target === \"draft-2020-12\") {\n                            json.prefixItems = prefixItems;\n                        }\n                        else {\n                            json.items = prefixItems;\n                        }\n                        if (def.rest) {\n                            const rest = this.process(def.rest, {\n                                ...params,\n                                path: [...params.path, \"items\"],\n                            });\n                            if (this.target === \"draft-2020-12\") {\n                                json.items = rest;\n                            }\n                            else {\n                                json.additionalItems = rest;\n                            }\n                        }\n                        // additionalItems\n                        if (def.rest) {\n                            json.items = this.process(def.rest, {\n                                ...params,\n                                path: [...params.path, \"items\"],\n                            });\n                        }\n                        // length\n                        const { minimum, maximum } = schema._zod.bag;\n                        if (typeof minimum === \"number\")\n                            json.minItems = minimum;\n                        if (typeof maximum === \"number\")\n                            json.maxItems = maximum;\n                        break;\n                    }\n                    case \"record\": {\n                        const json = _json;\n                        json.type = \"object\";\n                        json.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, \"propertyNames\"] });\n                        json.additionalProperties = this.process(def.valueType, {\n                            ...params,\n                            path: [...params.path, \"additionalProperties\"],\n                        });\n                        break;\n                    }\n                    case \"map\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Map cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"set\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Set cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"enum\": {\n                        const json = _json;\n                        const values = getEnumValues(def.entries);\n                        // Number enums can have both string and number values\n                        if (values.every((v) => typeof v === \"number\"))\n                            json.type = \"number\";\n                        if (values.every((v) => typeof v === \"string\"))\n                            json.type = \"string\";\n                        json.enum = values;\n                        break;\n                    }\n                    case \"literal\": {\n                        const json = _json;\n                        const vals = [];\n                        for (const val of def.values) {\n                            if (val === undefined) {\n                                if (this.unrepresentable === \"throw\") {\n                                    throw new Error(\"Literal `undefined` cannot be represented in JSON Schema\");\n                                }\n                                else {\n                                    // do not add to vals\n                                }\n                            }\n                            else if (typeof val === \"bigint\") {\n                                if (this.unrepresentable === \"throw\") {\n                                    throw new Error(\"BigInt literals cannot be represented in JSON Schema\");\n                                }\n                                else {\n                                    vals.push(Number(val));\n                                }\n                            }\n                            else {\n                                vals.push(val);\n                            }\n                        }\n                        if (vals.length === 0) {\n                            // do nothing (an undefined literal was stripped)\n                        }\n                        else if (vals.length === 1) {\n                            const val = vals[0];\n                            json.type = val === null ? \"null\" : typeof val;\n                            json.const = val;\n                        }\n                        else {\n                            if (vals.every((v) => typeof v === \"number\"))\n                                json.type = \"number\";\n                            if (vals.every((v) => typeof v === \"string\"))\n                                json.type = \"string\";\n                            if (vals.every((v) => typeof v === \"boolean\"))\n                                json.type = \"string\";\n                            if (vals.every((v) => v === null))\n                                json.type = \"null\";\n                            json.enum = vals;\n                        }\n                        break;\n                    }\n                    case \"file\": {\n                        const json = _json;\n                        const file = {\n                            type: \"string\",\n                            format: \"binary\",\n                            contentEncoding: \"binary\",\n                        };\n                        const { minimum, maximum, mime } = schema._zod.bag;\n                        if (minimum !== undefined)\n                            file.minLength = minimum;\n                        if (maximum !== undefined)\n                            file.maxLength = maximum;\n                        if (mime) {\n                            if (mime.length === 1) {\n                                file.contentMediaType = mime[0];\n                                Object.assign(json, file);\n                            }\n                            else {\n                                json.anyOf = mime.map((m) => {\n                                    const mFile = { ...file, contentMediaType: m };\n                                    return mFile;\n                                });\n                            }\n                        }\n                        else {\n                            Object.assign(json, file);\n                        }\n                        // if (this.unrepresentable === \"throw\") {\n                        //   throw new Error(\"File cannot be represented in JSON Schema\");\n                        // }\n                        break;\n                    }\n                    case \"transform\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Transforms cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"nullable\": {\n                        const inner = this.process(def.innerType, params);\n                        _json.anyOf = [inner, { type: \"null\" }];\n                        break;\n                    }\n                    case \"nonoptional\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        break;\n                    }\n                    case \"success\": {\n                        const json = _json;\n                        json.type = \"boolean\";\n                        break;\n                    }\n                    case \"default\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        _json.default = JSON.parse(JSON.stringify(def.defaultValue));\n                        break;\n                    }\n                    case \"prefault\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        if (this.io === \"input\")\n                            _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));\n                        break;\n                    }\n                    case \"catch\": {\n                        // use conditionals\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        let catchValue;\n                        try {\n                            catchValue = def.catchValue(undefined);\n                        }\n                        catch {\n                            throw new Error(\"Dynamic catch values are not supported in JSON Schema\");\n                        }\n                        _json.default = catchValue;\n                        break;\n                    }\n                    case \"nan\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"NaN cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"template_literal\": {\n                        const json = _json;\n                        const pattern = schema._zod.pattern;\n                        if (!pattern)\n                            throw new Error(\"Pattern not found in template literal\");\n                        json.type = \"string\";\n                        json.pattern = pattern.source;\n                        break;\n                    }\n                    case \"pipe\": {\n                        const innerType = this.io === \"input\" ? (def.in._zod.def.type === \"transform\" ? def.out : def.in) : def.out;\n                        this.process(innerType, params);\n                        result.ref = innerType;\n                        break;\n                    }\n                    case \"readonly\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        _json.readOnly = true;\n                        break;\n                    }\n                    // passthrough types\n                    case \"promise\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        break;\n                    }\n                    case \"optional\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        break;\n                    }\n                    case \"lazy\": {\n                        const innerType = schema._zod.innerType;\n                        this.process(innerType, params);\n                        result.ref = innerType;\n                        break;\n                    }\n                    case \"custom\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Custom types cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    default: {\n                        def;\n                    }\n                }\n            }\n        }\n        // metadata\n        const meta = this.metadataRegistry.get(schema);\n        if (meta)\n            Object.assign(result.schema, meta);\n        if (this.io === \"input\" && isTransforming(schema)) {\n            // examples/defaults only apply to output type of pipe\n            delete result.schema.examples;\n            delete result.schema.default;\n        }\n        // set prefault as default\n        if (this.io === \"input\" && result.schema._prefault)\n            (_a = result.schema).default ?? (_a.default = result.schema._prefault);\n        delete result.schema._prefault;\n        // pulling fresh from this.seen in case it was overwritten\n        const _result = this.seen.get(schema);\n        return _result.schema;\n    }\n    emit(schema, _params) {\n        const params = {\n            cycles: _params?.cycles ?? \"ref\",\n            reused: _params?.reused ?? \"inline\",\n            // unrepresentable: _params?.unrepresentable ?? \"throw\",\n            // uri: _params?.uri ?? ((id) => `${id}`),\n            external: _params?.external ?? undefined,\n        };\n        // iterate over seen map;\n        const root = this.seen.get(schema);\n        if (!root)\n            throw new Error(\"Unprocessed schema. This is a bug in Zod.\");\n        // initialize result with root schema fields\n        // Object.assign(result, seen.cached);\n        const makeURI = (entry) => {\n            // comparing the seen objects because sometimes\n            // multiple schemas map to the same seen object.\n            // e.g. lazy\n            // external is configured\n            const defsSegment = this.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n            if (params.external) {\n                const externalId = params.external.registry.get(entry[0])?.id; // ?? \"__shared\";// `__schema${this.counter++}`;\n                // check if schema is in the external registry\n                if (externalId)\n                    return { ref: params.external.uri(externalId) };\n                // otherwise, add to __shared\n                const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;\n                entry[1].defId = id;\n                return { defId: id, ref: `${params.external.uri(\"__shared\")}#/${defsSegment}/${id}` };\n            }\n            if (entry[1] === root) {\n                return { ref: \"#\" };\n            }\n            // self-contained schema\n            const uriPrefix = `#`;\n            const defUriPrefix = `${uriPrefix}/${defsSegment}/`;\n            const defId = entry[1].schema.id ?? `__schema${this.counter++}`;\n            return { defId, ref: defUriPrefix + defId };\n        };\n        // stored cached version in `def` property\n        // remove all properties, set $ref\n        const extractToDef = (entry) => {\n            if (entry[1].schema.$ref) {\n                return;\n            }\n            const seen = entry[1];\n            const { ref, defId } = makeURI(entry);\n            seen.def = { ...seen.schema };\n            // defId won't be set if the schema is a reference to an external schema\n            if (defId)\n                seen.defId = defId;\n            // wipe away all properties except $ref\n            const schema = seen.schema;\n            for (const key in schema) {\n                delete schema[key];\n            }\n            schema.$ref = ref;\n        };\n        // extract schemas into $defs\n        for (const entry of this.seen.entries()) {\n            const seen = entry[1];\n            // convert root schema to # $ref\n            // also prevents root schema from being extracted\n            if (schema === entry[0]) {\n                // do not copy to defs...this is the root schema\n                extractToDef(entry);\n                continue;\n            }\n            // extract schemas that are in the external registry\n            if (params.external) {\n                const ext = params.external.registry.get(entry[0])?.id;\n                if (schema !== entry[0] && ext) {\n                    extractToDef(entry);\n                    continue;\n                }\n            }\n            // extract schemas with `id` meta\n            const id = this.metadataRegistry.get(entry[0])?.id;\n            if (id) {\n                extractToDef(entry);\n                continue;\n            }\n            // break cycles\n            if (seen.cycle) {\n                if (params.cycles === \"throw\") {\n                    throw new Error(\"Cycle detected: \" +\n                        `#/${seen.cycle?.join(\"/\")}/<root>` +\n                        '\\n\\nSet the `cycles` parameter to `\"ref\"` to resolve cyclical schemas with defs.');\n                }\n                else if (params.cycles === \"ref\") {\n                    extractToDef(entry);\n                }\n                continue;\n            }\n            // extract reused schemas\n            if (seen.count > 1) {\n                if (params.reused === \"ref\") {\n                    extractToDef(entry);\n                    // biome-ignore lint:\n                    continue;\n                }\n            }\n        }\n        // flatten _refs\n        const flattenRef = (zodSchema, params) => {\n            const seen = this.seen.get(zodSchema);\n            const schema = seen.def ?? seen.schema;\n            const _cached = { ...schema };\n            // already seen\n            if (seen.ref === null) {\n                return;\n            }\n            // flatten ref if defined\n            const ref = seen.ref;\n            seen.ref = null; // prevent recursion\n            if (ref) {\n                flattenRef(ref, params);\n                // merge referenced schema into current\n                const refSchema = this.seen.get(ref).schema;\n                if (refSchema.$ref && params.target === \"draft-7\") {\n                    schema.allOf = schema.allOf ?? [];\n                    schema.allOf.push(refSchema);\n                }\n                else {\n                    Object.assign(schema, refSchema);\n                    Object.assign(schema, _cached); // prevent overwriting any fields in the original schema\n                }\n            }\n            // execute overrides\n            if (!seen.isParent)\n                this.override({\n                    zodSchema: zodSchema,\n                    jsonSchema: schema,\n                });\n        };\n        for (const entry of [...this.seen.entries()].reverse()) {\n            flattenRef(entry[0], { target: this.target });\n        }\n        const result = {};\n        if (this.target === \"draft-2020-12\") {\n            result.$schema = \"https://json-schema.org/draft/2020-12/schema\";\n        }\n        else if (this.target === \"draft-7\") {\n            result.$schema = \"http://json-schema.org/draft-07/schema#\";\n        }\n        else {\n            console.warn(`Invalid target: ${this.target}`);\n        }\n        Object.assign(result, root.def);\n        // build defs object\n        const defs = params.external?.defs ?? {};\n        for (const entry of this.seen.entries()) {\n            const seen = entry[1];\n            if (seen.def && seen.defId) {\n                defs[seen.defId] = seen.def;\n            }\n        }\n        // set definitions in result\n        if (!params.external && Object.keys(defs).length > 0) {\n            if (this.target === \"draft-2020-12\") {\n                result.$defs = defs;\n            }\n            else {\n                result.definitions = defs;\n            }\n        }\n        try {\n            // this \"finalizes\" this schema and ensures all cycles are removed\n            // each call to .emit() is functionally independent\n            // though the seen map is shared\n            return JSON.parse(JSON.stringify(result));\n        }\n        catch (_err) {\n            throw new Error(\"Error converting schema to JSON.\");\n        }\n    }\n}\nexport function toJSONSchema(input, _params) {\n    if (input instanceof $ZodRegistry) {\n        const gen = new JSONSchemaGenerator(_params);\n        const defs = {};\n        for (const entry of input._idmap.entries()) {\n            const [_, schema] = entry;\n            gen.process(schema);\n        }\n        const schemas = {};\n        const external = {\n            registry: input,\n            uri: _params?.uri || ((id) => id),\n            defs,\n        };\n        for (const entry of input._idmap.entries()) {\n            const [key, schema] = entry;\n            schemas[key] = gen.emit(schema, {\n                ..._params,\n                external,\n            });\n        }\n        if (Object.keys(defs).length > 0) {\n            const defsSegment = gen.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n            schemas.__shared = {\n                [defsSegment]: defs,\n            };\n        }\n        return { schemas };\n    }\n    const gen = new JSONSchemaGenerator(_params);\n    gen.process(input);\n    return gen.emit(input, _params);\n}\nfunction isTransforming(_schema, _ctx) {\n    const ctx = _ctx ?? { seen: new Set() };\n    if (ctx.seen.has(_schema))\n        return false;\n    ctx.seen.add(_schema);\n    const schema = _schema;\n    const def = schema._zod.def;\n    switch (def.type) {\n        case \"string\":\n        case \"number\":\n        case \"bigint\":\n        case \"boolean\":\n        case \"date\":\n        case \"symbol\":\n        case \"undefined\":\n        case \"null\":\n        case \"any\":\n        case \"unknown\":\n        case \"never\":\n        case \"void\":\n        case \"literal\":\n        case \"enum\":\n        case \"nan\":\n        case \"file\":\n        case \"template_literal\":\n            return false;\n        case \"array\": {\n            return isTransforming(def.element, ctx);\n        }\n        case \"object\": {\n            for (const key in def.shape) {\n                if (isTransforming(def.shape[key], ctx))\n                    return true;\n            }\n            return false;\n        }\n        case \"union\": {\n            for (const option of def.options) {\n                if (isTransforming(option, ctx))\n                    return true;\n            }\n            return false;\n        }\n        case \"intersection\": {\n            return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);\n        }\n        case \"tuple\": {\n            for (const item of def.items) {\n                if (isTransforming(item, ctx))\n                    return true;\n            }\n            if (def.rest && isTransforming(def.rest, ctx))\n                return true;\n            return false;\n        }\n        case \"record\": {\n            return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n        }\n        case \"map\": {\n            return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n        }\n        case \"set\": {\n            return isTransforming(def.valueType, ctx);\n        }\n        // inner types\n        case \"promise\":\n        case \"optional\":\n        case \"nonoptional\":\n        case \"nullable\":\n        case \"readonly\":\n            return isTransforming(def.innerType, ctx);\n        case \"lazy\":\n            return isTransforming(def.getter(), ctx);\n        case \"default\": {\n            return isTransforming(def.innerType, ctx);\n        }\n        case \"prefault\": {\n            return isTransforming(def.innerType, ctx);\n        }\n        case \"custom\": {\n            return false;\n        }\n        case \"transform\": {\n            return true;\n        }\n        case \"pipe\": {\n            return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);\n        }\n        case \"success\": {\n            return false;\n        }\n        case \"catch\": {\n            return false;\n        }\n        default:\n            def;\n    }\n    throw new Error(`Unknown schema type: ${def.type}`);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}